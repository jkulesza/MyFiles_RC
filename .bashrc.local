#!/bin/bash

################################################################################
# Generic customizations.
################################################################################

alias :e=vim
alias :q=exit
alias ..="cd .."

alias c="cd && clear"
alias cd..="cd .."
alias d='ls --color'
alias data='cd /data/`whoami`'
alias displayset="export DISPLAY=`echo $SSH_CONNECTION | awk '{print $1}' | sed 's/::ffff://' | sed 's/$/:0/'`"
alias displayunset='export DISPLAY='
alias g="git"
alias gitl="git log --pretty=format:'%h | %an | %s'"
alias gv='gvim'
alias h='history | tail -n 15'
alias la='ls -al'
alias listvnc="ps aux | grep Xvnc | grep -v grep | awk '{print \$12,\$1}' | sed 's/://' | sort"
alias lS='ls -lsShr'
alias lst='echo ; set tda = `date --iso-8601` ; ls -lat --time-style=long-iso | grep "$tda" '
alias path='echo $PATH | tr ":" "\n" | sort | uniq | sort'
alias print='$HOME/bin/print.sh'
alias ps2pdf='ps2pdf -sPAPERSIZE=letter'
alias vi='vim -X'
alias vncserver='vncserver -geometry 1100x880'
alias xterm='xterm +sb -bg black -fg grey90'

# Setup SSH aliases.  Kept private to keep destinations anonymous.
source .dotfiles_private/.bashrc.ssh_aliases_generic

# Configure custom aliases in $HOME/bin.
if [ -d "$HOME/bin" ]; then
  alias pwf="$HOME/bin/pwf.sh"
  export PATH="$HOME/bin:$PATH"
fi

export EDITOR=vim

# Configure custom software path in $HOME directory.  This is useful for package
# manager deployment (e.g., MacPorts) or self-compiled and installed software.
if [ -d "$HOME/SW/$(hostname -s)" ]; then
  # Set paths to generic installation location based on machine (because some
  # file spaces are shared).
  export SW=$HOME/SW/$(hostname -s)
  export PATH=$SW/bin:$PATH
  export LD_LIBRARY_PATH=$SW/lib:$LD_LIBRARY_PATH

  # Update default editor to self-compiled vim, if available.
  if [ -f $SW/bin/vim ]; then
    export EDITOR=$SW/bin/vim
  fi

  # Setup PYTHONPATH recognizing that on various machiens various major/minor
  # version of Python might have been used
  for vmajor in {2..3}; do
    for vminor in {0..9}; do
      if [ -d $SW/lib/python$vmajor.$vminor/site-packages/ ]; then
        export PYTHONPATH=$SW/lib/python$vmajor.$vminor/site-packages/:$PYTHONPATH
      fi
      if [ -d $SW/lib64/python$vmajor.$vminor/site-packages/ ]; then
        export PYTHONPATH=$SW/lib64/python$vmajor.$vminor/site-packages/:$PYTHONPATH
      fi
    done
  done

fi

# Customize prompt (old style).
    RESET="\[\033[0;38m\]"
    BLACK="\[\033[0;30m\]"
      RED="\[\033[0;31m\]"
 LIGHTRED="\[\033[1;31m\]"
     GREY="\[\033[0;37m\]"
    WHITE="\[\033[0;38m\]"
   YELLOW="\[\033[1;33m\]"
     TEAL="\[\033[0;36m\]"

   BG_RED="\[\033[30;41m\]"
BG_YELLOW="\[\033[30;43m\]"
  BG_TEAL="\[\033[30;46m\]"

export PS1HOST=$WHITE

# Attempt to force correct line-wrapping behavior by correctly recognizing the
# window dimensions.  Status can be checked with `shopt  | grep checkwinsize`.
# From: http://unix.stackexchange.com/questions/105958/terminal-prompt-not-wrapping-correctly
shopt -s checkwinsize

# Set command line to respond (somewhat) like vi
set -o vi

# Allow clobbering of files.
set +o noclobber

# Ignore duplicate entries in the Bash history.
export HISTCONTROL=ignoreboth:erasedups
export HISTSIZE=10000
export HISTFILESIZE=10000
shopt -s histappend

################################################################################
# OS-specific customization.
################################################################################

if [[ `uname` == 'Darwin' ]]; then
  source .bashrc.os_darwin
elif [[ `uname` == 'Linux' ]]; then
  source .bashrc.os_linux
fi

################################################################################
# Machine-specific customization.
################################################################################

if [ ${HOSTNAME} == "tempest" ]; then # Office iMac
  source .bashrc.machine_tempest
elif [ ${HOSTNAME} == "uncalculated" ]; then # Personal Machine
  source .bashrc.machine_uncalculated
elif [ ${HOSTNAME} == "vm" ]; then # Virtual Machine
  source .bashrc.machine_vm
elif [ ${HOSTNAME} == "gale" ]; then  # Laptop
  source .bashrc.machine_gale
fi

################################################################################
# Final customizations.
################################################################################

# Set prompt.
PROMPT_COMMAND='set_bash_prompt'

################################################################################
# Functions.
################################################################################

# Extract pages from a PDF.
pdfextr() {
   # this function uses 3 arguments:
   #     $1 is the first page of the range to extract
   #     $2 is the last page of the range to extract
   #     $3 is the input file
   #     output file will be named "inputfile_pXX-pYY.pdf"
   gs -sDEVICE=pdfwrite -dNOPAUSE -dBATCH -dSAFER \
      -dFirstPage=${1} \
      -dLastPage=${2} \
      -sOutputFile=${3%.pdf}_p${1}-p${2}.pdf \
      ${3}
}

# View terminal colors / color codes.
colors() {
  local fgc bgc vals seq0

  printf "Color escapes are %s\n" '\e[${value};...;${value}m'
  printf "Values 30..37 are \e[33mforeground colors\e[m\n"
  printf "Values 40..47 are \e[43mbackground colors\e[m\n"
  printf "Value  1 gives a  \e[1mbold-faced look\e[m\n\n"

  # foreground colors
  for fgc in {30..37}; do
     # background colors
     for bgc in {40..47}; do
        fgc=${fgc#37} # white
        bgc=${bgc#40} # black

        vals="${fgc:+$fgc;}${bgc}"
        vals=${vals%%;}

        seq0="${vals:+\e[${vals}m}"
        printf "  %-9s" "${seq0:-(default)}"
        printf " ${seq0}TEXT\e[m"
        printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
     done
     echo; echo
  done
}

# From http://misc.flogisoft.com/bash/tip_colors_and_formatting#terminals_compatibility
colors16() {
for clbg in {40..47} {100..107} 49 ; do
	#Foreground
	for clfg in {30..37} {90..97} 39 ; do
		#Formatting
		for attr in 0 1 2 4 5 7 ; do
			#Print the result
			echo -en "\e[${attr};${clbg};${clfg}m ^[${attr};${clbg};${clfg}m \e[0m"
		done
		echo #Newline
	done
done
}

# From http://misc.flogisoft.com/bash/tip_colors_and_formatting#terminals_compatibility
colors256() {
for fgbg in 38 48 ; do #Foreground/Background
	for color in {0..256} ; do #Colors
		#Display the color
		echo -en "\e[${fgbg};5;${color}m ${color}\t\e[0m"
		#Display 10 colors per lines
		if [ $((($color + 1) % 10)) == 0 ] ; then
			echo #New line
		fi
	done
	echo #New line
done
}

# Print all 256 terminal colors, one per row.
aa_256 () {
  ( x=`tput op` y=`printf %$((${COLUMNS}-6))s`;
  for i in {0..256};
  do
  o=00$i;
  echo -e ${o:${#o}-3:3} `tput setaf $i;tput setab $i`${y// /=}$x;
  done )
}

# Called by PROMPT_COMMAND to cusotmize the prompt each time it is displayed.
# This permits live updating of the current git branch (provided and styled by
# get_git_branch).
set_bash_prompt() {
  # Get git branch for pwd.
  if [[ $(git symbolic-ref HEAD 2>/dev/null) ]]; then
    get_git_branch
  else
    git_branch=""
  fi

  # Override prompt if root is being used.
  if [ `whoami` == "root" ]; then
    export PS1="${git_branch}$RED\! \\u@$PS1HOST\\h$RED[\\w]> "
  else
    export PS1="${git_branch}$RESET\! \\u@$PS1HOST\\h$RESET[\\w]> "
  fi

  # Set terminal title.
  printf "\033]0;%s\007" "${HOSTNAME%%.*}"

}

# Function to obtain the current git branch for the current working directory.
# Note the lack of escape codes on the colors.
get_git_branch() {
  DARKGREY='\033[90m'
  RESET='\033[0m'
  git_branch=`git symbolic-ref HEAD 2>/dev/null | sed 's/^.*\/\(.*\)/[Git(\1)]/g'`
  git_branch="${DARKGREY}${git_branch}${RESET}\n"
}
